# c_ Component
#     """
#     Базовый интерфейс Компонента определяет поведение, которое изменяется
#     декораторами.
#     """
#
#     ___ operation  __ st.
#         p..
#
#
# c_ ConcreteComponent C..
#     """
#     Конкретные Компоненты предоставляют реализации поведения по умолчанию. Может
#     быть несколько вариаций этих классов.
#     """
#
#     ___ operation  __ st.
#         r_ "ConcreteComponent"
#
#
# c Decorator C..
#     """
#     Базовый класс Декоратора следует тому же интерфейсу, что и другие
#     компоненты. Основная цель этого класса - определить интерфейс обёртки для
#     всех конкретных декораторов. Реализация кода обёртки по умолчанию может
#     включать в себя поле для хранения завёрнутого компонента и средства его
#     инициализации.
#     """
#
#     _component; C.. _ N..
#
#     ___ - component C.. __ N..
#         _?  ?
#
#     ??
#     ___ component __ st.
#         """
#         Декоратор делегирует всю работу обёрнутому компоненту.
#         """
#
#         r_ _c..
#
#     ___ operation __ st.
#         _c___.o..
#
#
# c ConcreteDecoratorA D..
#     """
#     Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
#     некоторым образом.
#     """
#
#     ___ operation __ st.
#         """
#         Декораторы могут вызывать родительскую реализацию операции, вместо того,
#         чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает
#         расширение классов декораторов.
#         """
#         r_ _*CDA||.c___.o...
#
#
# c ConcreteDecoratorB D..
#     """
#     Декораторы могут выполнять своё поведение до или после вызова обёрнутого
#     объекта.
#     """
#
#     ___ operation  __ st.
#         r_ _*CDB||?c___.o...
#
#
# ___ client_code component C.. __ N..
#     """
#     Клиентский код работает со всеми объектами, используя интерфейс Компонента.
#     Таким образом, он остаётся независимым от конкретных классов компонентов, с
#     которыми работает.
#     """
#
#     # ...
#
#     print(_*RESULT: |c___.o..", en._"")
#
#     # ...
#
#
# __ _______ __ ______
#     # Таким образом, клиентский код может поддерживать как простые компоненты...
#     simple = C..
#     print("Client: I've got a simple component:")
#     client_code ?
#     print("\n")
#
#     # ...так и декорированные.
#     #
#     # Обратите внимание, что декораторы могут обёртывать не только простые
#     # компоненты, но и другие декораторы.
#     decorator1 = CDA ?
#     decorator2 = CDB ?
#     print("Client: Now I've got a decorated component:")
#     client_code ?
#
#
# # Client: I've got a simple component:
# # RESULT: ConcreteComponent
# #
# # Client: Now I've got a decorated component:
# # RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))