# # # -*- coding: utf-8 -*-
#
# ____ -f ______ a..
# ____ a.. ______ ABC a..
# ____ ty.. ______ L..
#
#
# c_ Component A..
#     """
#     Интерфейс Компонента объявляет метод accept, который в качестве аргумента
#     может получать любой объект, реализующий интерфейс посетителя.
#     """
#
#     ??
#     ___ accept  visitor V.. __ N..
#         p..
#
#
# c_ ConcreteComponentA C..
#     """
#     Каждый Конкретный Компонент должен реализовать метод accept таким образом,
#     чтобы он вызывал метод посетителя, соответствующий классу компонента.
#     """
#
#     ___ accept  visitor V.. __ N..
#         """
#         Обратите внимание, мы вызываем visitConcreteComponentA, что
#         соответствует названию текущего класса. Таким образом мы позволяем
#         посетителю узнать, с каким классом компонента он работает.
#         """
#
#         ?.v_a ?
#
#     ___ exclusive_method_of_concrete_component_a __ s..
#         """
#         Конкретные Компоненты могут иметь особые методы, не объявленные в их
#         базовом классе или интерфейсе. Посетитель всё же может использовать эти
#         методы, поскольку он знает о конкретном классе компонента.
#         """
#
#         r_ "A"
#
#
# c_ ConcreteComponentB C..
#     """
#     То же самое здесь: visitConcreteComponentB => ConcreteComponentB
#     """
#
#     ___ accept visitor V..
#         ?.v_b
#
#     ___ special_method_of_concrete_component_b __ s..
#         r_ "B"
#
#
# c_ Visitor A..
#     """
#     Интерфейс Посетителя объявляет набор методов посещения, соответствующих
#     классам компонентов. Сигнатура метода посещения позволяет посетителю
#     определить конкретный класс компонента, с которым он имеет дело.
#     """
#
#     ??
#     ___ visit_concrete_component_a element C_A __ N..
#         p..
#
#     ??
#     ___ visit_concrete_component_b element C_B __ N..
#         p..
#
#
# """
# Конкретные Посетители реализуют несколько версий одного и того же алгоритма,
# которые могут работать со всеми классами конкретных компонентов.
#
# Максимальную выгоду от паттерна Посетитель вы почувствуете, используя его со
# сложной структурой объектов, такой как дерево Компоновщика. В этом случае было
# бы полезно хранить некоторое промежуточное состояние алгоритма при выполнении
# методов посетителя над различными объектами структуры.
# """
#
#
# c_ ConcreteVisitor1 V..
#     ___ visit_concrete_component_a element __ N..
#         print _*|?.e_a + C_1")
#
#     ___ visit_concrete_component_b element __ N..
#         print _*|?.s_b()} + C_1")
#
#
# c_ ConcreteVisitor2(Visitor):
#     ___ visit_concrete_component_a element __ N..
#         print _*|?.e_a + C_2")
#
#     ___ visit_concrete_component_b element __ N..
#         print _*|?.s_b + C_2")
#
#
# ___ client_code(components L.. |C.... visitor V.. __ N..
#     """
#     Клиентский код может выполнять операции посетителя над любым набором
#     элементов, не выясняя их конкретных классов. Операция принятия направляет
#     вызов к соответствующей операции в объекте посетителя.
#     """
#
#     # ...
#     ___ component __ c...
#         ?.ac.. v..
#     # ...
#
#
# __ ________ __ _________
#     components = C_A C_B
#
#     print("The client code works with all visitors via the base Visitor interface:")
#     visitor1 = CV_1
#     c_c.. c.. v_1
#
#     print("It allows the same client code to work with different types of visitors:")
#     visitor2 = CV_2
#     c_c.. c.. v_2