# ____ -f ______ a..
# ____ a.. ______ A.. a..
# ____ ty.. ______ L..
#
#
# c_ Component A..
#     """
#     Базовый класс Компонент объявляет общие операции как для простых, так и для
#     сложных объектов структуры.
#     """
#
#     ??
#     ___ parent __ C..
#         r_ _p..
#
#     ??.?
#     ___ parent parent C..
#         """
#         При необходимости базовый Компонент может объявить интерфейс для
#         установки и получения родителя компонента в древовидной структуре. Он
#         также может предоставить некоторую реализацию по умолчанию для этих
#         методов.
#         """
#
#         self._?  ?
#
#     """
#     В некоторых случаях целесообразно определить операции управления потомками
#     прямо в базовом классе Компонент. Таким образом, вам не нужно будет
#     предоставлять конкретные классы компонентов клиентскому коду, даже во время
#     сборки дерева объектов. Недостаток такого подхода в том, что эти методы
#     будут пустыми для компонентов уровня листа.
#     """
#
#     ___ add component C.. __ N..
#         p..
#
#     ___ remove component: C.. __ N..
#         p..
#
#     ___ is_composite __ b..
#         """
#         Вы можете предоставить метод, который позволит клиентскому коду понять,
#         может ли компонент иметь вложенные объекты.
#         """
#
#         r_ F..
#
#     ??
#     ___ operation__ st.
#         """
#         Базовый Компонент может сам реализовать некоторое поведение по умолчанию
#         или поручить это конкретным классам, объявив метод, содержащий поведение
#         абстрактным.
#         """
#
#         p..
#
#
# c_ Leaf C..
#     """
#     Класс Лист представляет собой конечные объекты структуры. Лист не может
#     иметь вложенных компонентов.
#
#     Обычно объекты Листьев выполняют фактическую работу, тогда как объекты
#     Контейнера лишь делегируют работу своим подкомпонентам.
#     """
#
#     ___ operation __ ?
#         r_ "Leaf"
#
#
# c_ Composite C..
#     """
#     Класс Контейнер содержит сложные компоненты, которые могут иметь вложенные
#     компоненты. Обычно объекты Контейнеры делегируют фактическую работу своим
#     детям, а затем «суммируют» результат.
#     """
#
#     ___ - __ N..
#         _children: L..|C.. _     # list
#
#     """
#     Объект контейнера может как добавлять компоненты в свой список вложенных
#     компонентов, так и удалять их, как простые, так и сложные.
#     """
#
#     ___ add, component C.. __ N..
#         _ch___.ap.. ?
#         ?.p.. _ ____
#
#     ___ remove component C.. __ N..
#         _ch___.r.. ?
#         ?.p.. _ N..
#
#     ___ is_composite __ b..
#         r_ T..
#
#     ___ operation __ ?
#         """
#         Контейнер выполняет свою основную логику особым образом. Он проходит
#         рекурсивно через всех своих детей, собирая и суммируя их результаты.
#         Поскольку потомки контейнера передают эти вызовы своим потомкам и так
#         далее, в результате обходится всё дерево объектов.
#         """
#
#         results  _  # list
#         ___ child in _c..
#             r___.ap.. ?.op..
#         r_ _*Branch||'+'.j.. r___"
#
#
# ___ client_code component C.. __ N..
#     """
#     Клиентский код работает со всеми компонентами через базовый интерфейс.
#     """
#
#     print(_*RESULT: |?.o..", e.._"")
#
#
# ___ client_code2 component1 C.. component2 C.. __ N..
#     """
#     Благодаря тому, что операции управления потомками объявлены в базовом классе
#     Компонента, клиентский код может работать как с простыми, так и со сложными
#     компонентами, вне зависимости от их конкретных классов.
#     """
#
#     __ _1.is_
#         _1.ad. _2
#
#     print _*RESULT: |_1.o...", e.._"")
#
#
# __ _______ __ ______
#     # Таким образом, клиентский код может поддерживать простые компоненты-
#     # листья...
#     simple = L..
#     print("Client: I've got a simple component:")
#     c.. ?
#     print("\n")
#
#     # ...а также сложные контейнеры.
#     tree = C..
#
#     branch1 = C..
#     ?.a.. L..
#     ?.a.. L..
#
#     branch2 = C..
#     ?.a.. L..
#
#     t__.a.. _1
#     t__.a.. _2
#
#     print("Client: Now I've got a composite tree:")
#     c_c_ t__
#     print("\n")
#
#     print("Client: I don't need to check the components classes even when managing the tree:")
#     c_c_2(t___ s..