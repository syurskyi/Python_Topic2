# ____ -f ______ an..
# ____ a.. ______ A.. a..m..
#
#
# c_ AbstractFactory A..
#     """
#     Интерфейс Абстрактной Фабрики объявляет набор методов, которые возвращают
#     различные абстрактные продукты. Эти продукты называются семейством и связаны
#     темой или концепцией высокого уровня. Продукты одного семейства обычно могут
#     взаимодействовать между собой. Семейство продуктов может иметь несколько
#     вариаций, но продукты одной вариации несовместимы с продуктами другой.
#     """
#     ??
#     ___ create_product_a __ A_A
#         p..
#
#     ??
#     ___ create_product_b __ A_B
#         p..
#
#
# c_ ConcreteFactory1 A..
#     """
#     Конкретная Фабрика производит семейство продуктов одной вариации. Фабрика
#     гарантирует совместимость полученных продуктов. Обратите внимание, что
#     сигнатуры методов Конкретной Фабрики возвращают абстрактный продукт, в то
#     время как внутри метода создается экземпляр конкретного продукта.
#     """
#
#     ___ create_product_a __ C_A1
#         r_ C_A1
#
#     ___ create_product_b __ C_B1
#         r_ C_B1
#
#
# c_ ConcreteFactory2 A..
#     """
#     Каждая Конкретная Фабрика имеет соответствующую вариацию продукта.
#     """
#
#     ___ create_product_a __ C_A2
#         r_ C_A2
#
#     ___ create_product_b __ C_B2
#         r_ C_B2
#
#
# c_ AbstractProductA A..
#     """
#     Каждый отдельный продукт семейства продуктов должен иметь базовый интерфейс.
#     Все вариации продукта должны реализовывать этот интерфейс.
#     """
#
#     ??
#     ___ useful_function_a __ st.
#         p..
#
#
# """
# Конкретные продукты создаются соответствующими Конкретными Фабриками.
# """
#
#
# c_ ConcreteProductA1(A_A
#     ___ useful_function_a __ st.
#         r_ "The result of the product A1."
#
#
# c_ ConcreteProductA2(A_A
#     ___ useful_function_a __ st.
#         r_ "The result of the product A2."
#
#
# c_ AbstractProductB A..
#     """
#     Базовый интерфейс другого продукта. Все продукты могут взаимодействовать
#     друг с другом, но правильное взаимодействие возможно только между продуктами
#     одной и той же конкретной вариации.
#     """
#     ??
#     ___ useful_function_b __ N..
#         """
#         Продукт B способен работать самостоятельно...
#         """
#         p..
#
#     ??
#     ___ another_useful_function_b  collaborator A_A __ N..
#         """
#         ...а также взаимодействовать с Продуктами Б той же вариации.
#
#         Абстрактная Фабрика гарантирует, что все продукты, которые она создает,
#         имеют одинаковую вариацию и, следовательно, совместимы.
#         """
#         p..
#
#
# """
# Конкретные Продукты создаются соответствующими Конкретными Фабриками.
# """
#
#
# c_ ConcreteProductB1(A_B
#     ___ useful_function_b __ st.
#         r_ "The result of the product B1."
#
#     """
#     Продукт B1 может корректно работать только с Продуктом A1. Тем не менее, он
#     принимает любой экземпляр Абстрактного Продукта А в качестве аргумента.
#     """
#
#     ___ another_useful_function_b collaborator A_A __ st.
#         result = ?.u_a
#         r_ _*The result of the B1 collaborating with the ||?
#
#
# c_ ConcreteProductB2(A_B
#     ___ useful_function_b __ st.
#         r_ "The result of the product B2."
#
#     ___ another_useful_function_b collaborator A_A
#         """
#         Продукт B2 может корректно работать только с Продуктом A2. Тем не менее,
#         он принимает любой экземпляр Абстрактного Продукта А в качестве
#         аргумента.
#         """
#         result = ?.u_a
#         r_ _*The result of the B2 collaborating with the ||? "
#
#
# ___ client_code factory A.. __ N..
#     """
#     Клиентский код работает с фабриками и продуктами только через абстрактные
#     типы: Абстрактная Фабрика и Абстрактный Продукт. Это позволяет передавать
#     любой подкласс фабрики или продукта клиентскому коду, не нарушая его.
#     """
#     product_a = ?.c_a
#     product_b = ?.c_b
#
#     print(_* p_b.u_b
#     print(_* p_b.a_b p_a" en._"")
#
#
# __ _______ __ _____
#     """
#     Клиентский код может работать с любым конкретным классом фабрики.
#     """
#     print("Client: Testing client code with the first factory type:")
#     c_c..(C_1
#
#     print("\n")
#
#     print("Client: Testing the same client code with the second factory type:")
#     c_c..C_2