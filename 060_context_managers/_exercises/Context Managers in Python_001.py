# # # # -*- coding: utf-8 -*-
#
# # Несколько лет назад, в Python 2.5 добавили новое ключевое слово, под названием оператор with.
# # Это новое ключевое слово позволяет разработчику создавать контекстные менеджеры. Но подождите,
# # что же такое контекстный менеджер? Это удобные конструкции, которые позволяют разработчику настраивать
# # что-нибудь и разрывать в автоматическом режиме. Например, вам может потребоваться открыть файл,
# # вписать в него кучу всего и закрыть. Это классический пример работы контекстного менеджера. Фактически,
# # Python создает один такой экземпляр автоматически каждый раз, когда вы открываете файл, используя оператор with:
#
#  o... path '_' a_ f_obj
#     ?.w.. some_data
#
# # Это работает путем использования двух волшебных методов Python: __enter__ и __exit__.
# # Давайте попробуем создать собственный контекстный менеджер, чтобы увидеть, как это работает на практике.
#
# # Создаем класс Context Manager
# #
# # Вместо того, чтобы переписывать открытый метод Python, мы создадим контекстный менеджер, который создает связь
# # с базой данных SQLite, и закрывает её по окончанию работы. Вот простой пример:
#
# ______ sq..3
#
#
# c_ DataConn
#
#     ___ __i__ ____ db_name
#         """Конструктор"""
#         ____.d.. _ d..
#
#     ___ __e__ ____)
#         """
#         Открываем подключение с базой данных.
#         """
#         ____.conn _ s...3.con.. ____.d..
#         r_ ____.conn
#
#     ___ __e__ ____ exc_type exc_val exc_tb
#         """
#         Закрываем подключение.
#         """
#         ____.co__.cl..
#         i_ e.._v..
#             r..
#
#
# __ ______ __ ______
#     db _ test.db
#
#      D... ? a_ conn
#         cursor _ c___.cu...
#
# # В данном коде мы создали класс, который берет путь к файлу базы данных SQLite Python. Метод __enter__ выполняется
# # автоматически, он создает и возвращает объект связи базы данных. Теперь мы можем создать курсор для записи
# # в базу данных или чтобы её запросить. Когда мы выходим из оператора with, метод __exit__ запускается,
# # закрывая таким образом связь. Давайте попробуем создать контекстный менеджер при помощи другого метода.
# # Создание контекстного менеджера с использованием contextlib
# #
# # В Python 2.5 добавили не только оператор with, но также модуль contextlib.
# # Это позволяет нам создать контекстный менеджер, используя функцию модуля contextlib под названием contextmanager
# # в качестве декоратора. Давайте попробуем создать контекстный менеджер который открывает и закрывает
# # файл после проделанной в нем работе:
#
# f___ c..l.. ______ c..m..
#
# 0c..m..
# ___ file_open(path
#     t__
#         f_obj = o...(path, 'w')
#         y___ f_obj
#     e__ OSE..
#         print("We had an error!")
#     f_____
#         print('Closing file')
#         ?.cl..
#
#
# __ ______ __ ______
#      f... test.txt a_ fobj
#         ?.w.. Testing context managers
#
# # Здесь мы просто импортируем contextmanager из contextlib и декорируем нашу функцию file_open с ним.
# # Это позволяет нам вызвать file_open используя оператор with. В нашей функции мы открываем файл, отдаем его,
# # чтобы функция calling могла использовать его. После того, как оператор закончит, контроль возвращается обратно
# # к функции file_open, которая продолжает следовать по коду за вызываемым оператором. Это приводит оператор finally
# # к исполнению, благодаря которому и закрывается файл. Если возникла ошибка OSError во время работы с файлом,
# # она будет выявлена и оператор finally закроет обработчик файлов несмотря на это.
#
# # contextlib.closing()
# # Модуль contextlib содержит несколько полезных утилит. Первая – это класс closing, который закроет объект
# # по завершению определенного блока кода. В документации Python есть пример кода, похожий на следующий:
#
# from contextlib ______ c..m..
#
# 0c..m..
# ___ closing db
#     t__
#         y___ db.c..
#     f____
#         ?.c..
#
# # В целом, мы создаем закрывающую функцию, которая завернута в контекстный менеджер.
# # Это эквивалент того, что делает класс closing. Но есть небольшая разница: вместо декоратора,
# # мы можем использовать класс class в нашем операторе with. Давайте взглянем:
#
# f___ c..l.. ______ cl...
# f____ u___.req.. ______ u..o..
#
#  cl... u..o.. http://www.google.com a_ webpage
#     ___ line i_ w...
#         # обрабатываем строку...
#         p___
#
# # В данном примере мы открыли страницу URL, но обернули её в наш класс closing.
# # Это приведет к закрытию дескриптора веб-страницы, сразу после выхода из блока кода оператора with.
#
# # contextlib.suppress(*exceptions)
# #
# # Еще один полезный инструмент — класс suppress, который был добавлен в Python 3.4.
# # Идея в том, что данная утилита контекстного менеджера может подавлять любое количество исключений.
# # Скажем, нам нужно проигнорировать исключение FileNotFoundError. Если прописать следующий контекстный менеджер,
# # то это не сработает:
#
#  o... fauxfile.txt a_ fobj
#     ___ line i_ ?
#         print l..
#
# # Traceback (most recent call last):
# #     Python Shell, prompt 4, line 1
# # builtins.F.. [Errno 2] No such file or directory: 'fauxfile.txt'
#
# # Как мы видим, этот контекстный менеджер не выполняет обработку данного исключения.
# # Если вам нужно проигнорировать эту ошибку, лучше напишите следующий код:
#
# f___ c..l.. ______ sup..
#
#  sup... F..N..F..E..
#      o... fauxfile.txt a_ fobj
#         ___ line i_ ?
#             print l..
#
# # Здесь мы импортируем suppress и передаем его исключению FileNotFoundError. Если вы запустите этот код, вы увидите,
# # что ничего не происходит, так как файл не существует, но и ошибка не возникает. Обратите внимание на то,
# # что этот контекстный менеджер является реентрабельным, но об этом позже.
#
# # contextlib.redirect_stdout / redirect_stderr
# #
# # Библиотека contextlib содержит несколько замечательных инструментов для перенаправления stdout и stderr,
# # которые появились в Python 3.4 и 3.5 соответственно. До того, как эти инструменты появились, и когда вам нужно
# # перенаправить stdout, вам нужно сделать что-то на подобии этого:
#
# path _ '/path/to/text.txt'
# ______ sy..
#  o... path '_' a_ fobj
#     sy_.s..o.. _ ?
#     help su.
#
# # С модулем contextlib вы можете сделать следующее:
#
# f___ c..l.. ______ re.._s..o..
#
# path _ '/path/to/text.txt'
#  o... path '_' a_ fobj
#      r...._s.. ?
#         h.. ?
#
# # В обоих примерах мы перенаправили stdout к файлу. Когда мы вызываем справку Python, вместо вывода в stdout,
# # она сохраняется непосредственно в файле. Вы также можете перенаправить stdout в какой-нибудь буфер или текстовый
# # инструмент управления из арсенала пользовательского интерфейса, вроде Tkinter или wxPython.
# # ExitStack
# #
# # ExitStack – это контекстный менеджер, который позволит вам легко комбинировать другие контекстные менеджеры,
# # а также функции очистки. Звучит немного запутанно, на первый взгляд, так что давайте рассмотрим простой пример
# # из документации Python, с его помощью будет проще уловить суть:
#
# f___ c..l.. ______ E..S..
#
#  E... a_ stack
#     file_objects _ [
#         ?.en.._c.. o... f... ___ filename i_ filenames
#
# # В общем и целом, данный код создает серию контекстных менеджеров внутри списка. ExitStack поддерживает
# # стек регистрируемых колбеков, которые вызываются в обратом порядке когда экземпляр закрыт, что и происходит,
# # когда мы выходим из части the оператора with. В документации Python существует великое множество метких примеров
# # работы contextlib, где вы можете ознакомиться с такими темами как:
# #
# #     Выявление исключений из методов __enter__
# #     Поддержки переменного количества контекстных менеджеров
# #     Замена любого применения try-finally
# #     И многое другое!
# #
# # Я настоятельно рекомендую ознакомиться с этими темами, так как вы поймете, насколько эффективным и
# # полезным может быть этот класс.
#
# # Реентерабельные контекстные менеджеры
# #
# # Большая часть создаваемых вами контекстных менеджеров может быть написана только для использования с оператором
# # with для одноразового применения. Вот пример:
#
# f___ c..l.. ______ c..m..
#
# 0c..m..
# ___ single
#     print('Yielding')
#     y_____
#     print('Exiting context manager')
#
# context _ s...
#  c...
#     p..
#
# # Результат:
# # Yielding
# # Exiting context manager
#
#  # context:
#  #    pass
#
# # Traceback (most recent call last):
# #    Python Shell, prompt 9, line 1
# #    File "/usr/local/lib/python3.5/contextlib.py", line 61, in __enter__
# #       raise RuntimeError("generator didn't yield") from None
# # builtins.RuntimeError: generator didn't yield
#
# # Здесь мы создали экземпляр контекстного менеджера и пытаемся запустить его дважды с оператором with.
# # Второй запуск приводит к ошибке RuntimeError. Но что делать, если нам необходимо,
# # чтобы контекстный менеджер запускался дважды? Для этой цели нам и нужен реентрабельный контекстный менеджер.
# # Давайте используем менеджер redirect_stdout, который мы применяли ранее.
#
# f___ c..l.. ______ r.._s..o..
# f___ io ______ S..I.
#
# stream _ ?
# write_to_stream _ r.._s..o.. s..
#  wr..
#     print('Write something to the stream')
#      wr..
#         print('Write something else to stream')
#
# print s___.g..v..
#
# # Результат
# # Write something to the stream
# # Write something else to stream
#
# # Здесь мы создали вложенные контекстные менеджеры, которые оба пишут в StringIO, который является текстовым потоком
# # в памяти. Причина, по которой это работает, а не приводит к ошибке RuntimeError, как было ранее в том,
# # что redirect_stdout является реентрабельным и позволяет нам вызывать его дважды. Конечно, ситуации в реальной жизни
# # могут быть заметно сложнее, когда мы работаем с большим количеством функций, которые вызывают друг друга.
# # Пожалуйста, обратите также внимание на то, что контекстные менеджеры не обязательно являются защищенными от потоков.
# # Обратитесь к документации, перед тем как использовать их в потоках во избежание путаницы.
# # Подведем итоги
# #
# # Контекстный менеджер – крайне полезный и удобный инструмент, способный выручить во многих ситуациях.
# # Я пользуюсь ими в своих автоматических тестах постоянно, для открытия и закрытия диалогов, например.
# # Теперь вы можете использовать ряд встроенных в Python инструментов для создания собственных контекстных менеджеров.
# # Убедитесь в том, что вы выделили достаточно времени для изучения документации Python о contextlib,
# # так как в ней хранится очень много дополнительной полезной информации, которая не была рассмотрена в данной статье.
