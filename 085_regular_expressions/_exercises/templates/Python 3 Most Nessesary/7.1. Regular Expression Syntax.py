# # -*- coding: utf-8 -*-

# L или LOCALE - учитываются настройки текущей локали;
# r или IGNORECASE - поиск без учета регистра. Пример:

# ____ __
# p = __.c__ _"1? а-яе + 2?", __.3? _ __.4?  # 1.Starts with | 2.Ends with | 3.case-insensitive matching
#                                            # 4.Interprets letters according to the Unicode character set
# print("Найдено" __ ?.se.. АБВГДЕЕ ___ "Нет")
# # Найдено
# p = __.c__ _"1? а-яе + 2?", __.3?    # 1.Starts with  | 2.Ends with | 3.Interprets letters according to the Unicode character set
# print("Найдено" __ ?.se.. АБВГДЕЕ ____ "Нет")
# # Нет
#
# м или МULTILINE - поиск в строке, состоящей из нескольких подстрок, разделенных
# символом новой строки ("\n"). Символ ,.._ соответствует привязке к началу каждой подстроки, а символ $ - позиции перед
# символом перевода строки;
# + s или OOTP...LL - метасимвол «точка» по умолчанию соответствует любому символу, кроме символа перевода строки
# ( \. :--;). Символу перевода строки метасимвол «точка» будет
# соответствовать в прис) -тствии дополнительного модификатора. Символ л соответствует
# привязке к началу всей строю1. а символ .s - привязке к концу всей строки.

# 
# p = __.c__ _"1?.2?"  # 1.Starts with | 2.Ends with
# print("Найдено" __ p.se..("\n") ____ "Нет")
# # Нет
# p = __.c__ _"1?.2?", __.3?  # 1.Starts with | 2.Ends with | 3.Makes $ match the end  and  ^ match the start
# print("Найдено" __ p.se..("\n") ____ "Нет")
# # Нет
# p = __.c__ _"1?.2?", __.3?  # 1.Starts with | 2.Ends with | 3.Makes a period (dot) match any character, including a newline.
# print("Найдено" __ p.se..("\n") ____ "Нет")
# # Найдено
#
# х или VERBOSE- если флаг указан. то пробелы и символы перевода строки будут проигнорированы. Внутри регулярного
# выражения можно использовать и комментарии.
# 
# p = __.c__(r"""1?     # Привязка к началу строки
#               0-9 + # Строка должна содержать одну цифру (или более)
#               2?      # Привязка к концу строки
#         """, __.3?  __.4?)                                      # 1.Starts with | 2.Ends with | 3.Permits "cuter" regular expression syntax | 4.Makes a period (dot) match any character, including a newline.
# print("Найдено" __ p.se.. 1234567890 ____ "Нет")
# # Найдено
# print("Найдено" __ p.se.. abcd123 ____ "Нет")
# # Нет
#
# А или Ascrr - классы \w, \W, \Ь, \В, \d, \D, \s и \S будут соответствовать символам в кодировке ASCII
# (по умолчанию перечисленные классы соответствуют Uniсоdесимволам).
# ПРИМЕЧАНИЕ
# Флаги u и UNICODE, включающие режим соответствия Unicode-cимsoлaм классов \w, \W, \Ь,
# \В, \d, \D, \s и \S, сохранены в Python З лишь для совместимости с ранними версиями этого языка и никакого влияния
# на обработку регулярных выражений не оказывают.
# Как видно из примеров, перед всеми строками, содержащими регулярные выражения, указан модификатор r. Иными словами,
# мы используем неформатированные строки. Если модификатор не указать, то все слеши необходимо экранировать.

# p = __.c__ _ 1? 2? 3? 4?     # 1.Starts with | 2.string contains any word characters | 3.matches one or more occurrences | 4.Ends with
# 
# p = __.c__ 1? 2? 3? 4? 5?      # 1.Starts with | 2.слеши необходимо экранировать | 3.string contains any word characters | 4.matches one or more occurrences  | 5.Ends with

# Внутри регулярного выражения символы .• ", $, *, +, ?, {, [, ], \, 1, (и) имеют специальное
# значение. Если эти символы должны трактоваться как есть, их следует экранировать с помощью слеша.
# Некоторые специальные символы теряют свое особое значение, если их разместить внутри квадратных скобок, -
# в этом случае экранировать их не нужно. Например,
# как уже бьmо отмечено ранее, метасимвол «точка» по умолчанию соответствует любому
# символу, кроме символа перевода строки. Если необходимо найти именно точку, то перед
# точкой нужно указать символ \ или разместить точку внутри квадратных скобок: [ . J
