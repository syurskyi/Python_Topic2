# deque
#
# В соответствии с документацией Python, deque – это обобщение стеков и очередей. Они являются контейнером замен
# для списка Python. Они защищены от потоков и поддерживают эффективность соединения памяти, а также сноски с обеих
# сторон deque. Список оптимизирован под быстрые операции с фиксированной длиной. За всеми подробностями можете
# обратиться к документации Python. Наш deque поддерживает аргумент maxlen, который устанавливает границы для deque.
# В противном случае deque будет расти до произвольных размеров. Когда ограниченный deque заполнен, любые новые объекты,
# которые были добавлены, вызовут такое же количество элементов, которые выскочат с другого конца. Вот основное правило:
# если вам нужно что-то быстро дописать или вытащить, используйте deque. Если вам нужен быстрый случайный доступ,
# используйте list. Давайте уделим пару минут, и посмотрим, как мы можем создавать и использовать deque.

from collections import deque
import string

d = deque(string.ascii_lowercase)
for letter in d:
    print(letter)

# Здесь мы импортируем deque из нашего модуля collections, а также модуль string. Для того, чтобы создать экземпляр
# deque, нам нужно передать его итерируемой. В данном случае, мы передали его string.ascii_lowercase, и получили
# список всех строчных букв в алфавите. Наконец, мы сделали цикл над deque и вывели каждый объект. Теперь давайте
# взглянем на несколько методов, которыми обладает deque.

d.append('bork')
print(d)

# deque(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
#        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'bork'])

d.appendleft('test')
print(d)

# deque(['test', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
#        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'bork'])

d.rotate(1)
print(d)

# deque(['bork', 'test', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
#        'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])

# Давайте устроим небольшой разбор полетов. Сначала мы разместили строку в правом краю deque. Далее разместили другую
# строку в левом краю deque. Наконец, мы вызываем rotate в нашем deque и передаем его единице,
# что заставляет его сместиться один раз в право. Другими словами, это заставляет один объект сместиться с правой части
# на фронтальную. Вы можете передать ему отрицательное число, чтобы происходило то же самое, но с левой стороны.
# Давайте закончим этот раздел и взглянем на пример, основанный на документации Python:

from collections import deque


def get_last(filename, n=5):
    """
    Возвращаем последние N кол-во строк из файла
    """
    try:
        with open(filename) as f:
            return deque(f, n)
    except OSError:
        print("Файл не открывается: {}".format(filename))
        raise

# Этот код работает по схожему принципу с программой-хвостом Linux. Здесь мы передаем имя файла нашему скрипту вместе
# с n количеством строк, которые мы хотим вернуть. Наш deque ограничен той или иной цифрой, которую мы указываем как n.
# Это значит, что как только deque заполнится, когда новые строки прочитаны и добавлены в deque, старые строки выпадают
# из другого конца и отбрасываются. Я также завернул открываемый в операторе файл в простой обработчик исключений,
# так как очень легко выполнить передачу по неверному пути. Таким образом, мы поймаем несуществующие файлы, к примеру.
# Теперь мы готовы идти дальше и приступить к изучению namedtuple.

