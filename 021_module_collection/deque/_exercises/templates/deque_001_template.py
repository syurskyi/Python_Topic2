# # # # -*- coding: utf-8 -*-
#
# # deque
# #
# # В соответствии с документацией Python, deque – это обобщение стеков и очередей. Они являются контейнером замен
# # для списка Python. Они защищены от потоков и поддерживают эффективность соединения памяти, а также сноски с обеих
# # сторон deque. Список оптимизирован под быстрые операции с фиксированной длиной. За всеми подробностями можете
# # обратиться к документации Python. Наш deque поддерживает аргумент maxlen, который устанавливает границы для deque.
# # В противном случае deque будет расти до произвольных размеров. Когда ограниченный deque заполнен, любые новые объекты,
# # которые были добавлены, вызовут такое же количество элементов, которые выскочат с другого конца. Вот основное правило:
# # если вам нужно что-то быстро дописать или вытащить, используйте deque. Если вам нужен быстрый случайный доступ,
# # используйте list. Давайте уделим пару минут, и посмотрим, как мы можем создавать и использовать deque.
#
# f_ c_ ______ d...
# _______ str...
#
# d _ d... st__.as.._lo..
# ___ letter i_ d
#     print l..
#
# # Здесь мы импортируем deque из нашего модуля collections, а также модуль string. Для того, чтобы создать экземпляр
# # deque, нам нужно передать его итерируемой. В данном случае, мы передали его string.ascii_lowercase, и получили
# # список всех строчных букв в алфавите. Наконец, мы сделали цикл над deque и вывели каждый объект. Теперь давайте
# # взглянем на несколько методов, которыми обладает deque.
#
# d.ap.. 'bork'
# print(d)
#
# # deque(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
# #        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'bork'])
#
# d.a..l.. 'test'
# print(d)
#
# # deque(['test', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
# #        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'bork'])
#
# d.ro.. 1
# print(d)
#
# # deque(['bork', 'test', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
# #        'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])
#
# # Давайте устроим небольшой разбор полетов. Сначала мы разместили строку в правом краю deque. Далее разместили другую
# # строку в левом краю deque. Наконец, мы вызываем rotate в нашем deque и передаем его единице,
# # что заставляет его сместиться один раз в право. Другими словами, это заставляет один объект сместиться с правой части
# # на фронтальную. Вы можете передать ему отрицательное число, чтобы происходило то же самое, но с левой стороны.
# # Давайте закончим этот раздел и взглянем на пример, основанный на документации Python:
#
# f_ c.. ______ d..
#
#
# ___ get_last filename n_5
#     """
#     Возвращаем последние N кол-во строк из файла
#     """
#     t..
#         w___ op.. fi.. a_ f
#             r__ d.. f n
#     e___ OSE..
#         print "Файл не открывается: ||".f.. f..
#         raise
#
# # Этот код работает по схожему принципу с программой-хвостом Linux. Здесь мы передаем имя файла нашему скрипту вместе
# # с n количеством строк, которые мы хотим вернуть. Наш deque ограничен той или иной цифрой, которую мы указываем как n.
# # Это значит, что как только deque заполнится, когда новые строки прочитаны и добавлены в deque, старые строки выпадают
# # из другого конца и отбрасываются. Я также завернул открываемый в операторе файл в простой обработчик исключений,
# # так как очень легко выполнить передачу по неверному пути. Таким образом, мы поймаем несуществующие файлы, к примеру.
# # Теперь мы готовы идти дальше и приступить к изучению namedtuple.
#
