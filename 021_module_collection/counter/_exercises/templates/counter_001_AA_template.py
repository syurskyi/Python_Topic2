# # # -*- coding: utf-8 -*-
#
# # Counter
# #
# # Модуль collections также предоставляет нам небольшой аккуратный инструмент, который поддерживает быстрый и удобный
# # в пользовании калькулятор. Этот инструмент называется Counter. Вы можете запустить его против большинства итерируемых.
# # Давайте попробуем взглянуть на него в строке.
#
# f.. c.. ________ C..
#
# a _ C.. 'superfluous'
#
# # Counter({'u': 3, 's': 2, 'e': 1, 'l': 1, 'f': 1, 'o': 1, 'r': 1, 'p': 1})
# print(a)
#
# counter = C.. 'superfluous'
# print c.. 'u'  # 3
#
# # В данном примере мы импортировали Counter из модуля collections и передали его строке.
# # Это возвращает нам объект Counter, который является наследуемым классом словаря Python. Когда мы запускаем эту
# # же команду, но назначаем её счетчик переменной, чтобы доступ к словарю был несколько проще. В данном случае,
# # мы видим, что буква “u” встречается три раза в нашем примере. Класс Counter предоставляет несколько методов,
# # которые могут вас заинтересовать. Например, вы можете вызывать элементы, которые будут выполнять итерацию над
# # элементами, расположенными в словаре, но в произвольном порядке. Вы можете подумать, что эта функция является своего
# # рода скремблером, так как выдача в этом случае представлена как скремблированная версия строки.
#
# print li.. c__.el..
# # ['e', 'l', 'f', 'o', 'r', 's', 's', 'p', 'u', 'u', 'u']
#
# # Еще один полезный метод это most_common. Вы можете спросить Counter о том, какие объекты являются наиболее
# # распространенными, передав число, отображающее наиболее часто повторяющие объекты “n”:
#
# printc__.m.._c.. 2
# # [('u', 3), ('s', 2)]
#
# # Здесь мы попросили наш Counter выяснить, какие два объекта являются наиболее повторяемыми. Как вы видите,
# # мы получили список кортежей, в котором указано, что “u” встречается 3 раза, а “s” – два раза. Еще один метод,
# # который я хотел бы рассмотреть, это метод subtract.
#
# # Метод subtract принимает итерируемые или отражения и использует этот аргумент для вычета.
# # Это немного проще понять, если взглянуть на код:
#
# f.. c.. ____ C..
#
# counter_one _ C.. 'superfluous'
#
# # Counter({'u': 3, 's': 2, 'e': 1, 'l': 1, 'f': 1, 'o': 1, 'r': 1, 'p': 1})
# print(c.._o..
#
# counter_two _ C.. 'super'
# c.._o__.su.. c.._t..
#
# print c.._o..
# # Counter({'u': 2, 'l': 1, 'f': 1, 'o': 1, 's': 1, 'e': 0, 'r': 0, 'p': 0})
#
# # Здесь мы создали заново наш первый счетчик и вывели его, чтобы узнать, что же в нем находится.
# # Далее мы создали второй объект Counter. Наконец, мы вычли второй счетчик из первого.
# # Если вы внимательно рассмотрите выдачу в конце, вы увидите, что количество букв для пяти объектов было уменьшено
# # на одну. Как я заметил в начале раздела, вы можете использовать Counter против любых итерируемых или сопоставлений,
# # так что вам не нужно использовать только строки. Вы можете также передать его кортежам, словарям и спискам!
# # Попробуйте на практике, чтобы увидеть, как он работает с разными типами данных:
# # Теперь мы готовы к тому, чтобы перейти к defaultdict!
