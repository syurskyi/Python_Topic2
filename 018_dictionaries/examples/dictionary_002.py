# Проверить существование кточа можно с помощью оператора in. Если ключ найден, то
# возвращается значение тrue, в противном случае - False.
d = {"a": 1, "b": 2}
print("a" in d) # Ключ существует
# True
print("c" in d) # Ключ не существует
# False

# Проверить, отсутствует ли какой-либо ключ в словаре, позволит оператор not in. Если
# ключ отсутствует, возвращается True, иначе - False.
d = {"a": 1, "b": 2}
print("c" not in d) # Ключ не существует
# True
print("a" not in d) # Ключ существует
# False

# get ( <Ключ> [, <Значение по умолчанию> ] )
# позволяет избежать возбуждения исключения KeyError при отсуtствии в словаре указанного ключа.
# Если ключ присутствует в словаре, то метод возвращает значение, соответствующее этому ключу.
# Если ключ отсутствует, то возвращается None или значение, указанное во втором параметре.
#
d = {"a": 1, "b": 2}
print(d.get("a"), d.get("c"), d.get("c", 800))
# # # (1, None, 800)

# setdefault ( <Kлюч> [, <Значение по умолчанию>])
# Если ключ присутствует в словаре, то метод возвращает значение, соответствующее
# этому ключу. Если ключ отсутствует, то в словаре создается новый элемент со значением, указанным во втором параметре.
# Если второй параметр не указан, значением нового элемента будет None.
#
d = {"a": 1, "b": 2}
print(d.setdefault("a"), d.setdefault("c"), d.setdefault("d", 0))
# (1, None, 0)
print(d)
# {'a': 1, 'c': None, 'b': 2, 'd': 0}

# Изменение элемента по ключу
d = {"a": 1, "b": 2}
d["a"] = 800 # Изменение элемента по ключу
d["c"] = "string" # Будет добавлен новый элемент
print(d)
# {'a': 800, 'c': 'string', 'b': 2}

# len ( )
d = {"a": 1, "b": 2}
print(len(d))  # Получаем количество ключей в словаре
# 2

# del()
d = {"a": 1, "b": 2}
del d["b"]; print(d)   # Удаляем элемент с ключом "b" и выводим словарь
# {'a': 1}

# Perebor elementov slovarja
d = {"x": 1, "y": 2, "z": 3}
for key in d.keys():
    print("({0} => {1})".format(key, d[key]), end=" ")
# Выведет: (y => 2) (x => 1) (z => 3)

for key in d:
    print("({0} => {1})".format(key, d[key]), end=" ")
# Выведет: (y => 2) (x => 1) (z => 3)

# Получаем список ключей
d = {"x": 1, "y": 2, "z": 3}
k = list(d.keys())  # Получаем список ключей
k.sort() # Сортируем список ключей
for key in k:
    print("({0} => {1})".format(key, d[key]), end=" ")
# Выведет: (x => 1) (y => 2) (z => 3)

# sorted ( )
d = {"x": 1, "y": 2, "z": 3}
for key in sorted(d.keys()):
    print("({0} => {1})".format(key, d[key]), end=" ")
# Выведет: (x => 1) (y => 2) (z => 3)

# Так как на каждой итерации возвращается кmоч словаря, функции sorted ( ) можно сразу передать объект словаря,
# а не результат выполнения метода keys () :

d = {"x": 1, "y": 2, "z": 3}
for key in sorted(d):
    print("({0} => {1})".format(key, d[key]), end=" ")
# Выведет: (x => 1) (y => 2) (z => 3)

# Методы  для работы со словарями
# keys ()

# возвращает объект  dict_keys, содержащий все ключи словаря. Этот объект
# поддерживает итерации, а также операции над множествами
#
d1, d2 = {"a": 1, "b": 2 }, {"a": 3, "c": 4, "d": 5}
print(d1.keys(), d2.keys())  # Получаем объект dict_keys
# (dict_keys(['a', 'b']), dict_keys(['a', 'c', 'd']))
print(list(d1.keys()), list(d2.keys()))
 # Получаем список ключей
# (['a', 'b'], ['a', 'c', 'd'])
for k in d1.keys():
  print(k, end=" ")

# Методы  для работы со словарями
# keys () - Объединение
d1, d2 = {"a": 1, "b": 2}, {"a": 3, "c": 4, "d": 5}
print(d1.keys() | d2.keys())
# {'a', 'c', 'b', 'd'}

# Методы  для работы со словарями
# keys () - Разница
d1, d2 = {"a": 1, "b": 2}, {"a": 3, "c": 4, "d": 5}
print(d1.keys() - d2.keys())
# {'b'}
print(d2.keys() - d1.keys())
# {'c', 'd'}