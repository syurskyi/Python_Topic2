# # -*- coding: utf-8 -*-
#
# """
# Для классов нового типа доступен другой способ, решающий описанные ранее
# проблемы. Существует специальный класс super, экземпляры которого являются
# специальными прокси-объектами, привязанными к данной иерархии классов
# и предоставляющими доступ к атрибутам следующего класса в линеаризации
# того класса, в котором был создан объект super.
#
# Таким образом, при помощи super можно получить доступ к атрибутам
# и методам суперкласса, не называя его имени, причём это будет давать
# корректные результаты даже при использовании множественного наследования.
#
# В Python 2 в качестве параметров конструктора super передаются текующий
# класс и экземпляр текущего класса. super ищет класс-предок в линеаризации
# указанного класса и все обращения к атрибутам созданного объекта отображаются
# на найденный класс, причём все методы привязаны к указанному объекту-экземпляру.
#
# Пример: super(MyClass, self).method()
#
# В Python 3 данные параметры можно не указывать. В таком случае будут
# автоматически получены текущий класс и экземпляр. То есть, вызов
#                super().method()
# эквивалентен
#                super(-c , self).method()
# """
#
#
# c_ Base o..
#     attr _ 'Base attribute'
#
#     ___ method ____
#         print('Base method, current class is', ____.-c .-n
#
#
# c_ Child ?
#     attr _ 'Redefined attribute'
#
#     ___ get_superclass_attr ____
#         r_ s___.a..  # получение атрибута класса Base
#
#     ___ method ____  # переопределение метода
#         s___.m..  # вызов метода суперкласса
#         print('Child method, current class is', ____.-c .-n
#
#
# ___ m..
#     print('Base:')
#     print(B___.a..
#     base_instance = B..
#     ?.m..
#
#     print()
#
#     print('Child:')
#     print(C__.a..
#     child_instance = C__
#     print(?.g..
#     ?.m..
#
#     print()
#
#     # В большинстве языков программирования, в которых есть конструкция,
#     # аналогичная super(), она может вызвана только внутри соответсвующего
#     # метода подкласса, причём часто только в качестве его первого оператора
#     # (впрочем, это наиболее типичный сценарий её использования).
#     # В Python, как "побочный эффект" того, как работает его реализация super,
#     # её можно вызвать где угодно, даже за пределами класса.
#     s___ C... ?.m..
#
#
# __ ______ __ ____
#     m...