# # -*- coding: utf-8 -*-
#
# """
# Если в данном классе атрибут или метод был переопределён,
# то доступ к соответствующему атрибуту суперкласса можно
# получить двумя способами.
#
# Первым из них, который был единственным до появления
# Python 2.3 и работает как для классов старого типа, так
# и для классов нового типа, является явное обращение к
# атрибутам суперкласса по его имени.
#
# Недостатки такого подхода:
#  - усложняется рефакторинг и поддержка кода (хотя эта проблема
#    решается путём использования таких IDE, как PyCharm);
#  - логика кода жёстко привязана к иерархии наследования классов
#    и подвержена ошибкам, особенно при использовании множественного
#    наследования.
# """
#
#
# c_ Base
#     attr _ 'Base attribute'
#
#     ___ method ____
#         print('Base method, current class is', ____. -c .-n
#
#
# c_ Child B..
#     attr _ 'Redefined attribute'
#
#     0s..
#     ___ get_superclass_attr
#         r_ B___.a..  # получение атрибута класса Base
#
#     ___ method ____  # переопределение метода
#         B__.m.. ____  # вызов метода суперкласса
#         print('Child method, current class is', ____. -c .-n
#
#
# ___ m..
#     print('Base:')
#     print B__.a..
#     base_instance = B..
#     ?.m...
#
#     print()
#
#     print('Child:')
#     print C_.a..
#     print(C__.g..
#     child_instance = C..
#     ?.m..
#
# ______ -n _____
#     m..
